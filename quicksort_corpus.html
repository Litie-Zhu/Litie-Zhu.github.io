<!DOCTYPE html>
<html>
<body>
<div id="__w2_ldL4PBq_container"><b>Quicksort, in essence, is a divide-and-conquer algorithm that sorts by partitioning and recursion.</b><br><br><div background-url="http://qph.is.quoracdn.net/main-qimg-f9969e71495a79d185b94d365db1314c?convert_to_webp=true" gif-embedded="http://qph.is.quoracdn.net/main-qimg-d4e5d0a778dba725091d8317e6bac939?convert_to_webp=true" is-playing="false" class="gif_noclick_wrapper"><img src="http://qph.is.quoracdn.net/main-qimg-f9969e71495a79d185b94d365db1314c?convert_to_webp=true" class="qtext_image" style="max-width: 100%;"><div class="gif_embed_noclick"></div></div><br>The above sentence might as well be Greek to you, and I understand that. That's why I'm going to start at the beginning, and that is an informal statement of the sorting problem.<br><br><b>Problem: </b>We are given as input an array, say of integers, with the numbers in some order. <br><br><b>Our Output: </b>We must provide the same array, but in sorted order, from least to greatest. i.e. - An array of [4, 2, 3, 1] --&gt; [1, 2, 3, 4].<br><br><div><img class="landscape qtext_image zoomable_in zoomable_in_feed" src="http://qph.is.quoracdn.net/main-qimg-d7a579424d707f3933390c74f63f9750?convert_to_webp=true" master_src="http://qph.is.quoracdn.net/main-qimg-2dc6c092af0ddef0c6cec94c61fc77e7?convert_to_webp=true" master_w="531" master_h="420"></div><br><br>Pretty simple problem to understand, if you ask me. Now on to Quicksort. Quicksort is one of the best general-purpose sorting algorithms available, and its <i>modus operandi </i>is arguably the most elegant to behold.<br><br><b>1. The Partition Idea</b><br><br>The essence of Quicksort is in the idea of partitioning. Partitioning works by taking a number x, and organizing the array by numbers less than x and numbers greater than x. This way, we bucket the numbers based on their comparative value to x, and we successfully <i>partition </i>the array: A much more modest goal compared to sorting.<br><br><div><img class="landscape qtext_image zoomable_in zoomable_in_feed" src="http://qph.is.quoracdn.net/main-qimg-9032d44c703b7f25797fbb9072c0dda6?convert_to_webp=true" master_src="http://qph.is.quoracdn.net/main-qimg-0b3c1438e251fada454cbf8bec302b77?convert_to_webp=true" master_w="493" master_h="241"></div><br>Conceptually, the image shows how the <i>partition subroutine </i>works, and gives an idea about the pseudocode. I'm sure you are interested in how this would translate into working code: Here's the general idea. Let's pick the first number of the array to be x. Then we define two numbers, i and j, to help us with partitioning. <b>i marks the division between the numbers less than the pivot and greater than the pivot, while j essentially just traverses the entire array.</b><br><br>What we do next is set up a for loop with j that goes through the entire array: if the element at index j of the array, or A[j], is greater than the pivot, we're golden. If A[j] &lt; A[0], we swap the element at index j with the element at index i. Then, we increment i, maintaining the division between numbers less than A[0], and greater than A[0]. Lastly, we swap the element at A[i - 1] with the pivot. <b>It is important to understand that after the partition subroutine, the pivot ends up in its rightful place. </b><br><br><div><img class="landscape qtext_image zoomable_in_feed" src="http://qph.is.quoracdn.net/main-qimg-65c54b3e9b6fef01a5ff7543ed3a3092?convert_to_webp=true" master_src="http://qph.is.quoracdn.net/main-qimg-65c54b3e9b6fef01a5ff7543ed3a3092?convert_to_webp=true" master_w="363" master_h="209"></div><br>Here's the pseudocode for the partition subroutine with the last element, rather than the first, as the <i>pivot element. </i><b>Understand that because the partition routine merely does a linear scan through the array, it runs in O(n) time.</b><br><br><b>2. Recursing Until The Array is Sorted</b><br><br>I hope you're familiar with the concept of recursion: If you aren't, recursion basically constitutes a method that keeps calling itself on increasingly smaller cases and repeats the same non-recursive procedure each time until it reaches some sort of base case, at which is stops. In the case of QuickSort, that would be when the length of the array is one, in which case no work needs to be done.<br><br>You might have realized that if this is not the case, the array is by no means sorted. This is why we call the QuickSort method again, twice, on arrays of smaller sizes. Namely, we recurse on the side of the array containing all the elements from A[0] to A[i - 2], and the side of array containing the elements A[i] to A[A.length - 1]. Why do we leave out A[i - 1]? Simple - It's already in its correct place.<br><br>This graphic illustrates the process quite well:<br><br><div><img class="landscape qtext_image zoomable_in_feed" src="http://qph.is.quoracdn.net/main-qimg-7325675c3ef299da10d03ad4786fe272?convert_to_webp=true" master_src="http://qph.is.quoracdn.net/main-qimg-7325675c3ef299da10d03ad4786fe272?convert_to_webp=true" master_w="326" master_h="320"></div><br>We recurse until we get to the base case, and voila - We have a sorted array. Success!<br><br><b>3. Choosing a Good Pivot</b><br><br>Surprisingly, or perhaps not, choosing a good pivot is crucial to the success of QuickSort. If the pivot is chosen poorly, for example, consistently the smallest or largest element in an array, or the first or last element in a nearly-sorted/reverse-sor<wbr>ted array, the complexity is O(<span class="math_w"><img src="http://qlx.is.quoracdn.net/main-f3ac1f48c7ef4f20.png" width="19" height="18" class="math" type="math" title="n^2" alt="n^2"></span>). This is because the algorithm recurses on an array of length n - 1, then n - 2...and so on, until it finally reaches 1. There are n - 1 levels, and each level, O(<span class="math_w"><img src="http://qlx.is.quoracdn.net/main-dd086fd4e318ca75.png" width="12" height="9" class="math" type="math" title="n" alt="n"></span>) work is done, resulting in that complexity.<br><br><div><img class="landscape qtext_image zoomable_in_feed" src="http://qph.is.quoracdn.net/main-qimg-91a9f93d6b9f20102d80481d4aaa773a?convert_to_webp=true" master_src="http://qph.is.quoracdn.net/main-qimg-91a9f93d6b9f20102d80481d4aaa773a?convert_to_webp=true" master_w="304" master_h="198"></div><br>I get it - We're almost done. So how do we choose a pivot good enough that we avoid this abysmal situation? There are a couple of strategies. One of them is randomized pivots, essentially picking a number at random from the array and using that as our pivot element. This makes it impossible to design a malicious input, and guards against the worst case.<br><br>The other strategy is to use the 'median-of-three' rule, which takes the first, middle, and last element, and takes the median of the three. This also makes it, probabilistically, extremely unlikely that the worst case occurs. <br><br><b>4. Analysis</b><br><br>We've identified that the absolute worst-case for QuickSort is <span class="math_w"><img src="http://qlx.is.quoracdn.net/main-737b56fe34746802.png" width="49" height="23" class="math" type="math" title="O(n^2)" alt="O(n^2)"></span>,<b> </b>and explored strategies for almost certainly avoiding this case. The best and average case for QuickSort is <span class="math_w"><img src="http://qlx.is.quoracdn.net/main-31f0b2d63bd34acf.png" width="82" height="21" class="math" type="math" title="O(n \ lg \ n)" alt="O(n \ lg \ n)"></span> - This is not a trivial proof, but you can explore that on your own time.<br><br><div><img class="landscape qtext_image zoomable_in zoomable_in_feed" src="http://qph.is.quoracdn.net/main-qimg-a029cd4e56fddba1b3894c5fabf66349?convert_to_webp=true" master_src="http://qph.is.quoracdn.net/main-qimg-14de7352d14a1d089bc59a479bf76082?convert_to_webp=true" master_w="600" master_h="400"></div>Yeah, we're done. Hope this helps, and enjoy!<div class="container_boundary" style="margin: 0px; padding: 0px; height: 0px; width: 0px;" id="__w2_ldL4PBq_container_boundary">&nbsp;&nbsp;</div></div>
</body>
</html>